
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>13 | 魔数 0x5f3759df</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="dirtysalt" />

<style type="text/css">html {
    font-family: Georgia, "Microsoft Yahei", "WenQuanYi Micro Hei";
}

/* pre { */
/*     background-color: #eee; */
/*     box-shadow: 5px 5px 5px #888; */
/*     border: none; */
/*     padding: 5pt; */
/*     margin-bottom: 14pt; */
/*     color: black; */
/*     padding: 12pt; */
/*     font-family: Consolas; */
/*     font-size: 95%; */
/*     overflow: auto; */
/* } */

.title  { /* text-align: center; */
          margin-bottom: 1em; }
.subtitle { /* text-align: center; */
            font-size: medium;
            font-weight: bold;
            margin-top:0; }
.todo   { font-family: monospace; color: red; }
.done   { font-family: monospace; color: green; }
.priority { font-family: monospace; color: orange; }
.tag    { background-color: #eee; font-family: monospace;
          padding: 2px; font-size: 80%; font-weight: normal; }
.timestamp { color: #bebebe; }
.timestamp-kwd { color: #5f9ea0; }
.org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
.org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
.org-center { margin-left: auto; margin-right: auto; text-align: center; }
.org-ul { padding-left: 10px; }
.org-ol { padding-left: 20px; }
ul { padding-left: 10px; }
ol { padding-left: 20px; }

.underline { text-decoration: underline; }
#postamble p, #preamble p { font-size: 90%; margin: .2em; }
p.verse { margin-left: 3%; }
pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
}
pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
}
pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
}
pre.src:hover:before { display: inline;}
pre.src-sh:before    { content: 'sh'; }
pre.src-bash:before  { content: 'sh'; }
pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
pre.src-R:before     { content: 'R'; }
pre.src-perl:before  { content: 'Perl'; }
pre.src-java:before  { content: 'Java'; }
pre.src-sql:before   { content: 'SQL'; }

table { border-collapse:collapse; }
caption.t-above { caption-side: top; }
caption.t-bottom { caption-side: bottom; }
td, th { vertical-align:top;  }
th.org-right  { text-align: center;  }
th.org-left   { text-align: center;   }
th.org-center { text-align: center; }
td.org-right  { text-align: right;  }
td.org-left   { text-align: left;   }
td.org-center { text-align: center; }
dt { font-weight: bold; }
.footpara { display: inline; }
.footdef  { margin-bottom: 1em; }
.figure { padding: 1em; }
.figure p { /* text-align: center; */ }
.inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
}
#org-div-home-and-up
{ text-align: right; font-size: 70%; white-space: nowrap; }
textarea { overflow-x: auto; }
.linenr { font-size: smaller }
.code-highlighted { background-color: #ffff00; }
.org-info-js_info-navigation { border-style: none; }
#org-info-js_console-label
{ font-size: 10px; font-weight: bold; white-space: nowrap; }
.org-info-js_search-highlight
{ background-color: #ffff00; color: #000000; font-weight: bold; }

/* http://www.yinwang.org/main.css */

body {
    /* font-family:"lucida grande", "lucida sans unicode", lucida, helvetica, "Hiragino Sans GB", "Microsoft YaHei", "WenQuanYi Micro Hei", sans-serif; */
    font-size: 18px;
    margin: 5% 5% 5% 5%;
    padding: 2% 5% 5% 5%;
    width: 80%;
    line-height: 150%;
    border: 1px solid LightGrey;
}

H1 {
    /* font-family: "Palatino Linotype", "Book Antiqua", Palatino, Helvetica, STKaiti, SimSun, serif; */
}

H2 {
    /* font-family: "Palatino Linotype", "Book Antiqua", Palatino, Helvetica, STKaiti, SimSun, serif; */
    margin-bottom: 60px;
    margin-bottom: 40px;
    padding: 5px;
    border-bottom: 2px LightGrey solid;
    width: 98%;
    line-height: 150%;
    color: #666666;
}


H3 {
    /* font-family: "Palatino Linotype", "Book Antiqua", Palatino, Helvetica, STKaiti, SimSun, serif; */
    margin-top: 40px;
    margin-bottom: 30px;
    border-bottom: 1px LightGrey solid;
    width: 98%;
    line-height: 150%;
    color: #666666;
}


H4 {
    /* font-family: "Palatino Linotype", "Book Antiqua", Palatino, Helvetica, STKaiti, SimSun, serif; */
    margin-top: 40px;
    margin-bottom: 30px;
    border-bottom: 1px LightGrey solid;
    width: 98%;
    line-height: 150%;
    color: #666666;
}


li {
    margin-left: 10px;
}


blockquote {
    border-left: 4px lightgrey solid;
    padding-left: 5px;
    margin-left: 20px;
}


pre {
    font-family: Inconsolata, Consolas, "DEJA VU SANS MONO", "DROID SANS MONO", Proggy, monospace;
    font-size: 75%;
    border: solid 1px lightgrey;
    background-color: Ivory;
    padding: 5px;
    line-height: 130%;
    margin-left: 10px;
    width: 95%;
}


code {
    font-family: Inconsolata, Consolas, "DEJA VU SANS MONO", "DROID SANS MONO", Proggy, monospace;
    font-size: 90%;
}


a {
    text-decoration: none;
    # cursor: crosshair;
    border-bottom: 1px dashed Red;
    padding: 1px;
    # color: black;
}


a:hover {
	background-color: LightGrey;
}


img {
    box-shadow: 0 0 10px #555;
    border-radius: 6px;
    margin-left: auto;
    margin-right: auto;
    margin-top: 10px;
    margin-bottom: 10px;
    -webkit-box-shadow: 0 0 10px #555;
    width: 100%;
    max-width: 600px;
}

img.displayed {
    display: block;
    margin-left: auto;
    margin-right: auto;
}

#table-of-contents {
    border-bottom: 2px LightGrey solid;
}</style>

</head>

<body>

<div class="outline-2">
<h2>13 | 魔数 0x5f3759df</h2>
<div class="outline-text-2">
<p>下列代码是在《雷神之锤III竞技场》源代码中的一个函数（已经剥离了C语言预处理器的指令）。其实，最早在2002年（或2003年）时，这段平方根倒数速算法的代码就已经出现在Usenet与其他论坛上了，并且也在程序员圈子里引起了热烈的讨论。</p>
<p>我先把这段代码贴出来，具体如下：</p>
<pre><code class="language-c">float Q_rsqrt( float number )
{
    long i;
    float x2, y;
    const float threehalfs = 1.5F;

    x2 = number * 0.5F;
    y  = number;
    i  = * ( long * ) &amp;y; // evil floating point bit level hacking
    i  = 0x5f3759df - ( i &gt;&gt; 1 );  // what the fuck? 
    y  = * ( float * ) &amp;i;
    y  = y * ( threehalfs - ( x2 * y * y ) );  // 1st iteration 
    // 2nd iteration, this can be removed
    // y  = y * ( threehalfs - ( x2 * y * y ) ); 

    return y;
}
</code></pre>
<p>这段代码初读起来，我是完全不知所云，尤其是那个魔数0x5f3759df，根本不知道它是什么意思，所以，注释里也是 What the fuck。今天的这篇文章里，我主要就是想带你来了解一下这个函数中的代码究竟是怎样出来的。</p>
<!-- [[[read_end]]] -->
<p>其实，这个函数的作用是求平方根倒数，即$x^{-1/2}$，也就是下面这个算式：</p>
<p>$$\frac{1}{\sqrt{x}}$$</p>
<p>当然，它算的是近似值。只不过这个近似值的精度很高，而且计算成本比传统的浮点数运算平方根的算法低太多。在以前那个计算资源还不充分的年代，在一些3D游戏场景的计算机图形学中，要求取照明和投影的光照与反射效果，就经常需要计算平方根倒数，而且是大量的计算——对一个曲面上很多的点做平方根倒数的计算。也就是需要用到下面的这个算式，其中的x,y,z是3D坐标上的一个点的三个坐标值。</p>
<p>$$\frac{1}{\sqrt{x^{2}+y^{2}+z^{2}}}$$</p>
<p>基本上来说，在一个3D游戏中，我们每秒钟都需要做上百万次平方根倒数运算。而在计算硬件还不成熟的时代，这些计算都需要软件来完成，计算速度非常慢。</p>
<p>我们要知道，在上世纪90年代，多数浮点数操作的速度更是远远滞后于整数操作。所以，这段代码所带来的作用是非常大的。</p>
<h1>计算机的浮点数表示</h1>
<p>为了讲清楚这段代码，我们需要先了解一下计算机的浮点数表示法。在C语言中，计算机的浮点数表示用的是IEEE 754 标准，这个标准的表现形式其实就是把一个32bits分成三段。</p>
<ul>
<li>第一段占1bit，表示符号位。代称为S（sign）。</li>
<li>第二段占8bits，表示指数。代称为E（Exponent）。</li>
<li>第三段占23bits，表示尾数。代称为M（Mantissa）。</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/cf/a2/cfb465ac3800ceb3f8a8997fe527c8a2.jpg" alt="" /></p>
<p>然后呢，一个小数的计算方式是下面这个算式：</p>
<p>$$(-1)^{S}\ast(1+\frac{M}{2^{23}})\ast 2^{(E-127)}$$</p>
<p>但是，这个算式基本上来说，完全就是让人一头雾水，摸不着门路。对于浮点数的解释基本上就是下面这张漫画里表现的样子。</p>
<p><img src="https://static001.geekbang.org/resource/image/7d/eb/7d607f3f90fe6e8152e2268da18e1feb.png" alt="" /></p>
<p>下面，让我来试着解释一下浮点数的那三段表示什么意思。</p>
<ul>
<li>
<p>第一段符号位。对于这一段，我相信应该没有人不能理解。</p>
</li>
<li>
<p>第二段指数位。什么叫指数？也就是说，对于任何数x，其都可以找到一个$n$，使得$2^{n}$&lt;=x&lt;=$2^{n+1}$。比如：对于3来说，因为 2 &lt; 3 &lt; 4，所以 n=1。而浮点数的这个指数为了要表示0.00x的小数，所以需要有负数，这8个bits本来可以表示0-255。为了表示负的，取值要放在 [-127,128] 这个区间中。这就是为什么我们在上面的公式中看到的 $2^{(E-127)}$这一项了。也就是说，$n = E-127$，如果$n=1$，那么$E$就是128了。</p>
</li>
<li>
<p>第三段尾数位。也就是小数位，但是这里叫偏移量可能好一些。这里的取值是从[ 0 - $2^{23}$]中。你可以认为，我们把一条线分成$2^{23}$个线段，也就是8388608个线段。也就是说，把$2^{n}$到$2^{n+1}$分成了8388608个线段。而存储的M值，就是从$2^n$到 x 要经过多少个段。这要计算一下，$2^{n}$到x的长度占$2^{n}$到$2^{n+1}$长度的比例是多少。</p>
</li>
</ul>
<p>我估计你对第三段还是有点不懂，那么我们来举一个例子。比如说，对3.14这个小数。</p>
<ul>
<li>
<p>是正数。所以，S = 0</p>
</li>
<li>
<p>$2^1$ &lt; 3.14 &lt;$2^2$。所以，n=1， n+127 = 128。所以，E=128。</p>
</li>
<li>
<p>(3.14 - 2) / (4 - 2) = 0.57， 而$0.57*2^{23} = 4781506.56$，四舍五入，得到M = 4781507。因为有四舍五入，所以，产生了浮点数据的精度问题。</p>
</li>
</ul>
<p>把S、E、M转成二进制，得到 3.14的二进制表示。</p>
<p><img src="https://static001.geekbang.org/resource/image/3f/15/3f99e711a80ebe963bd5ca4139224915.jpg" alt="" /></p>
<p>我们再用IEEE 754的那个算式来算一下：</p>
<p>$${(-1)}^0*({1+\frac{4781507}{2^{23}}})*2^{(128-127)}$$</p>
<p>$$1*(1+0.5700000524520874)*2$$<br />
$$=3.1400001049041748046875$$</p>
<p>你看，浮点数的精度问题出现了。</p>
<p>我们再来看一个示例，小数 0.015。</p>
<ul>
<li>
<p>是正数。所以，S = 0。</p>
</li>
<li>
<p>$2^{-7}&lt; 0.015 &lt; 2^{-6}$ 。所以，n=-7， n+127 = 120。所以，E=120。</p>
</li>
<li>
<p>$ (0.015 - 2^{-7}) / (2^{-6} - 2^{-7}) $ = $0.0071875/0.0078125=0.92$。而$0.92 * 2^{23} = 7717519.36$，四舍五入，得到 M = 7717519。</p>
</li>
</ul>
<p>于是，我们得到0.015的二进制编码：</p>
<p><img src="https://static001.geekbang.org/resource/image/bd/de/bd3c8cae032d818084f2d1ac0a02acde.jpg" alt="" /></p>
<p>其中：</p>
<ul>
<li>120 的二进制是01111000</li>
<li>7717519的二进制是11101011100001010001111</li>
</ul>
<p>返回过来算一下：</p>
<p>$$(-1)^{0}\ast (1+\frac{7717519}{2^{23}})\ast 2^{(120-127)}$$</p>
<p>$$(1+0.919999957084656)*0.0078125$$<br />
$$=0.014999999664724$$</p>
<p>你看，浮点数的精度问题又出现了。</p>
<p>我们来用C语言验证一下：</p>
<pre><code class="language-c">int main() {
    float x = 3.14;
    float y = 0.015;
    return 0;
}
</code></pre>
<p>在我的Mac上用lldb 工具 Debug 一下。</p>
<pre><code>(lldb) frame variable
(float) x = 3.1400001
(float) y = 0.0149999997

(lldb) frame variable -f b
(float) x = 0b01000000010010001111010111000011
(float) y = 0b00111100011101011100001010001111
</code></pre>
<p>从结果上，完全验证了我们的方法。</p>
<p>好了，不知道你看懂了没有？我相信你应该看懂了。</p>
<h1>简化浮点数公式</h1>
<p>因为那个浮点数表示的公式有点复杂，我们简化一下：</p>
<p>$$(-1)^{S}\ast (1+\frac{M}{2^{23}})\ast 2^{(E-127)}$$</p>
<p>我们令，$m = (\frac{M}{2^{23}} )$，$e = (E-127)$。因为符号位在$y= x^{-\frac{1}{2}}$的两端都是0（正数），也就可以去掉，所以浮点数的算式简化为：</p>
<p>$$(1+m)\ast2^{e}$$</p>
<p>上面这个算式是从一个32bits二进制计算出一个浮点数。这个32bits的整型算式是：</p>
<p>$$M+E\ast2^{23}$$</p>
<p>比如，0.015的32bits的二进制是：00111100011101011100001010001111，也就是整型的：</p>
<p>$$7717519+120\ast 2^{23}$$<br />
$$= 1014350479$$<br />
$$= 0X3C75C28F$$</p>
<h1>平方根倒数公式推导</h1>
<p>下面，你会看到好多数学公式，但是请你不要怕，因为这些数学公式只需要高中数学就能看懂的。</p>
<p>我们来看一下，平方根数据公式：</p>
<p>$$y=\frac{1}{\sqrt[2]{x}}=x^{-\frac{1}{2}}$$</p>
<p>等式两边取以2为基数的对数，就有了：</p>
<p>$$\log_2(y) =-\frac{1}{2}\log_2(x)$$</p>
<p>因为我们实际上在算浮点数，所以将公式中的 x 和 y 分别用浮点数的那个浮点数的简化算式$ (1+ m)*2^e$替换掉。代入$\log()$公式中，我们也就有了下面的公式：</p>
<p>$$\log_{2} (1+m_y)+e_y$$<br />
$$=-\frac{1}{2}(\log_2(1+m_x)+e_x)$$</p>
<p>因为有对数，这公式看着就很麻烦，似乎不能再简化了。但是，我们知道，所谓的$m_x$或是$m_y$，其实是个在0和1区间内的小数。在这种情况下，$\log_2 (1.x)$接近一条直线。</p>
<p><img src="https://static001.geekbang.org/resource/image/2d/4e/2d2b69795d3aa4d07545f0bbe645574e.png" alt="" /></p>
<p>那么我们就可以使用一个直线方程来代替，也就是：</p>
<p>$$\log_{2}(1+m)\approx m+\sigma $$</p>
<p>于是，我们的公式就简化成了：</p>
<p>$$m_y+\sigma+e_y\approx-\frac{1}{2}(m_x+\sigma+e_x)$$</p>
<p>因为$m = (\frac{M}{2^{23}})$，$e = (E-127)$，代入公式，得到：</p>
<p>$$\frac{M_y}{2^{23}}+\sigma+E_y-127$$<br />
$$\approx-\frac{1}{2}(\frac{M_x}{2^{23}}+\sigma+E_x-127)$$</p>
<p>移项整理一下，把 σ 和127 从左边，移到右边：</p>
<p>$$\frac{M_y}{2^{23}}+E_y\approx-\frac{1}{2}(\frac{M_x}{2^{23}}+E_x)-\frac{3}{2}(\sigma-127)$$</p>
<p>再把整个表达式乘以$2^{23}$，得到：</p>
<p>$${M_y}+E_y{2^{23}}$$<br />
$$\approx-\frac{1}{2}(M_x+E_x{2^{23}})-\frac{3}{2}(\sigma-127){2^{23}}$$</p>
<p>可以看到一个常数：$-\frac{3}{2}(\sigma-127){2^{23}}$，把负号放进括号里，变成$\frac{3}{2}(127-\sigma){2^{23}}$，并可以用一个常量代数R来取代，于是得到公式：</p>
<p>$${M_y}+E_y{2^{23}}\approx R-\frac{1}{2}(M_x+E_x{2^{23}})$$</p>
<p>还记得我们前面那个“浮点数32bits二进制整型算式” $M+E* 2^{23}$吗？假设，浮点数x的32bits的整型公式是：$I_x= M_x+ E_x  2^{23}$，那么上面的公式就可以写成：</p>
<p>$$I_y\approx R-\frac{1}{2}I_x$$</p>
<h1>代码分析</h1>
<p>让我们回到文章的主题，那个平方根函数的代码。</p>
<p>首先是：</p>
<pre><code>i  = * ( long * ) &amp;y; // evil floating point bit level hacking
</code></pre>
<p>这行代码就是把一个浮点数的32bits的二进制转成整型。也就是，前面我们例子里说过的，3.14的32bits的二进制是：01000000010010001111010111000011，整型是：1078523331。即y = 3.14，i = 1078523331。</p>
<p>然后是：</p>
<pre><code>i  = 0x5f3759df - ( i &gt;&gt; 1 );  // what the fuck? 
</code></pre>
<p>这就是：</p>
<pre><code>i  = 0x5f3759df - ( i / 2 );  
</code></pre>
<p>也就是我们上面推导出来的那个公式：</p>
<p>$$I_y\approx R-\frac{1}{2}I_x$$</p>
<p>代码里的 R = 0x5f3759df。</p>
<p>我们又知道，R = $\frac{3}{2}(127-\sigma){2^{23}}$，把代码中的那个魔数代入，就可以计算出来：σ= 0.0450465 。这个数是个神奇的数字，这个数是怎么算出来的，现在还没人知道。不过，我们先往下看后面的代码：</p>
<pre><code>    x2 = number * 0.5F;
    y  = * ( float * ) &amp;i;
    y  = y * ( threehalfs - ( x2 * y * y ) );  // 1st iteration 
    // 2nd iteration, this can be removed
    // y  = y * ( threehalfs - ( x2 * y * y ) ); 
</code></pre>
<p>这段代码相当于下面这个公式：</p>
<p>$$I_{y’} = I_y(1.5-0.5 x I_y^2)$$</p>
<p>这个其实是“牛顿求根法”，这是一个为了找到一个 f(x)= 0 的根而用一种不断逼近的计算方式。请看下图：</p>
<p><img src="https://static001.geekbang.org/resource/image/d9/e0/d9c070d857b29966ecb9eeab49057ce0.jpg" alt="" /></p>
<p>首先，初始值为X0，然后找到X0所对应的Y0（把X0代入公式得到Y0 = f(X0)），然后在（X0,Y0）这个点上做一个切线，得到与X轴交汇的X1。再用X1做一次上述的迭代，得到X2，就这样一直迭代下去，一直找到，y = 0时，x的值。</p>
<p>牛顿法的通用公式是：</p>
<p>$$x_{n+1}=x_n-\frac{f(x_n)}{f’(x_n)}$$</p>
<p>于是，对于$y= \frac{1}{\sqrt{x}}$来说，对固定的x（常数），我们求y使得$\frac{1}{y^2}-x=0$，$f(y)= \frac{1}{y^2} -x$ ,  $f’(y)=\frac{-2}{y^3}$ 。 注意：$f’(y)$是$f(y)$关于y的导数。</p>
<p>代入上述的牛顿法的通用公式后得到：</p>
<p>$$y_{n+1}=y_n-\frac{\frac{1}{y_n^2}-x}{\frac{-2}{y_n^3}}$$<br />
$$=\frac{y_n(3-xy_n^2)}{2}=y_n(1.5-0.5xy_n^2)$$</p>
<p>正好就是我们上面的代码。</p>
<p>整个代码是，之前生成的整数操作产生首次近似值后，将首次近似值作为参数送入函数最后两句进行精化处理。代码中的两次迭代正是为了进一步提高结果的精度。但由于《雷神之锤III》的图形计算中并不需要太高的精度，所以代码中只进行了一次迭代，二次迭代的代码则被注释了。</p>
<h1>相关历史</h1>
<p>根据Wikipedia上的描述，《雷神之锤III》的代码直到QuakeCon 2005才正式放出，但早在2002年（或2003年）时，平方根倒数速算法的代码就已经出现在Usenet和其他论坛上了。最初人们猜测是《雷神之锤》的创始人John Carmack写下了这段代码，但他在回复询问他的邮件时否定了这个观点，并猜测可能是先前曾帮id Software优化《雷神之锤》的资深汇编程序员Terje Mathisen写下了这段代码。</p>
<p>而Mathisen的邮件里表示，在1990年代初，他只曾做过类似的实现，确切来说这段代码亦非他所作。现在所知的最早实现是由Gary Tarolli在SGI Indigo中实现的，但他亦坦承他仅对常数R的取值做了一定的改进，实际上他也不是作者。</p>
<p>在向以发明MATLAB而闻名的Cleve Moler查证后，Rys Sommefeldt则认为原始的算法是Ardent Computer公司的Greg Walsh所发明的，但他也没有任何确定性的证据能证明这一点。</p>
<p>不仅该算法的原作者不明，人们也仍无法确定当初选择这个“魔术数字”的方法。Chris Lomont曾做了个研究：他推算出了一个函数以讨论此速算法的误差，并找出了使误差最小的最佳R值0x5f37642f（与代码中使用的0x5f3759df相当接近）。但以之代入算法计算并进行一次牛顿迭代后，所得近似值之精度仍略低于代入0x5f3759df的结果。</p>
<p>因此，Lomont将目标改为查找在进行1-2次牛顿迭代后能得到最大精度的R值，在暴力搜索后得出最优R值为0x5f375a86，以此值代入算法并进行牛顿迭代，所得的结果都比代入原始值（0x5f3759df）更精确。于是他说，“如果可能我想询问原作者，此速算法是以数学推导还是以反复试错的方式求出来的？”</p>
<p>Lomont亦指出，64位的IEEE754浮点数（即双精度类型）所对应的魔术数字是0x5fe6ec85e7de30da。但后来的研究表明，代入0x5fe6eb50c7aa19f9的结果精确度更高（McEniry得出的结果则是0x5fe6eb50c7b537aa，精度介于两者之间）。</p>
<p>后来Charles McEniry使用了一种类似Lomont但更复杂的方法来优化R值。他最开始使用穷举搜索，所得结果与Lomont相同。而后他尝试用带权二分法寻找最优值，所得结果恰是代码中所使用的魔术数字0x5f3759df。因此，McEniry认为，这一常数最初或许便是以“在可容忍误差范围内使用二分法”的方式求得。</p>
<p>这可能是编程世界里最经典的魔数的故事，希望你能够从这篇文章中收获一些数学的基础知识。数学真是需要努力学习好的一门功课，尤其在人工智能火热的今天。</p>
<p></p>

</div>
</div>

</body>
</html>